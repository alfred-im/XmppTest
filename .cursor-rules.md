# Regole importanti per lo sviluppo

## Indice delle regole

1. **Mappa del Progetto** - Genera/aggiorna mappa completa PRIMA di ogni task (FONDAMENTALE)
2. **Documentazione** - Scrivere SOLO per me stesso, MAI per l'utente (FONDAMENTALE)
3. **Metodo Analitico** - Approfondire e comprendere il problema (FONDAMENTALE)
4. **Analisi Architetturale** - Cercare errori di design prima di tutto (FONDAMENTALE)
5. **Principio di Certezza** - Agire solo con comprensione chiara (FONDAMENTALE)
6. **Revisione completa del codice** - PRIMA di modificare
7. **Debug e Testing** - NON chiedere all'utente
8. **Build** - SEMPRE dopo modifiche

---

## Mappa del Progetto - Genera/aggiorna mappa completa PRIMA di ogni task

**FONDAMENTALE: La mappa del progetto è il CONTRATTO dello stato del software. Il codice è VINCOLATO alla mappa.**

Questa è la regola più importante per stabilizzare la memoria e creare un "punto di verità" che garantisce coerenza architetturale.

### Regole fondamentali:
- ✅ **SEMPRE leggere `/workspace/PROJECT_MAP.md` all'inizio di OGNI sessione**
- ✅ **Il codice è VINCOLATO alla mappa - non fare modifiche non coerenti con l'architettura documentata**
- ✅ **SEMPRE aggiornare la mappa PRIMA di considerare completato qualsiasi lavoro che modifica architettura/struttura**
- ✅ **La mappa deve essere SEMPRE fedele allo stato attuale del software**
- ✅ **La mappa serve a COMPRENDERE L'ARCHITETTURA in modo dettagliato per fare implementazioni armoniche**
- ❌ **NON iniziare MAI una sessione senza aver letto la mappa del progetto**
- ❌ **NON fare modifiche architetturali senza verificare coerenza con la mappa**
- ❌ **NON lasciare MAI la mappa non sincronizzata con il codice**

### Cosa deve contenere la mappa:

1. **Struttura File**:
   - Tutti i file principali e loro responsabilità
   - Organizzazione directory
   - File di configurazione e loro scopo

2. **Architettura**:
   - Layer architetturali (UI, State, Services, Data)
   - Pattern utilizzati
   - Flussi di dati principali
   - Separazione delle responsabilità

3. **Dipendenze**:
   - Dipendenze npm (production + dev)
   - Versioni esatte e loro importanza
   - Dipendenze critiche (NON aggiornare senza testing)

4. **Entrypoint**:
   - Entry point principale dell'applicazione
   - Flow di inizializzazione
   - Setup globale

5. **Servizi Esterni**:
   - API esterne (es. XMPP server)
   - Servizi di terze parti
   - Configurazioni necessarie
   - Protocolli implementati (es. XEP per XMPP)

6. **Database e Storage**:
   - Database utilizzati (es. IndexedDB)
   - Schema database completo
   - Storage locale (localStorage, sessionStorage)
   - Repository pattern

7. **Stato Build**:
   - Tool di build (es. Vite)
   - Configurazione build
   - Script npm disponibili
   - Ottimizzazioni implementate

8. **Test Esistenti**:
   - Framework di testing
   - Test files esistenti
   - Coverage attuale
   - Scenari testati

9. **Stato Corrente**:
   - Feature implementate
   - Feature in roadmap
   - Known issues
   - Performance metrics
   - Security status

### Processo da seguire:

#### 1. All'inizio di OGNI sessione (OBBLIGATORIO):

```bash
# SEMPRE come PRIMO step di ogni sessione
Read /workspace/PROJECT_MAP.md
```

**Scopo**: Comprendere l'architettura completa del progetto prima di fare qualsiasi modifica.

#### 2. Durante il lavoro:

- **Usa la mappa come riferimento**: Ogni decisione architetturale deve essere coerente con la mappa
- **Verifica vincoli**: Il codice è VINCOLATO all'architettura documentata nella mappa
- **Non deviare**: Se serve deviare dall'architettura, PRIMA aggiorna la mappa per riflettere la nuova architettura

#### 3. Prima di completare il lavoro (OBBLIGATORIO):

Se hai fatto modifiche che cambiano:
- Struttura file o responsabilità
- Architettura o layer
- Dipendenze (aggiunte/rimosse/aggiornate)
- Database schema
- Servizi esterni
- Configurazione build
- Entrypoint o flow di inizializzazione

**DEVI aggiornare `/workspace/PROJECT_MAP.md` PRIMA di considerare il lavoro completato.**

#### 4. Workflow completo:

```
INIZIO SESSIONE
    ↓
[1] Leggi PROJECT_MAP.md (OBBLIGATORIO)
    ↓
[2] Comprendi architettura completa
    ↓
[3] Lavora sul task mantenendo coerenza con mappa
    ↓
[4] Se fai modifiche architetturali → Aggiorna PROJECT_MAP.md
    ↓
[5] Build e verifica
    ↓
FINE SESSIONE (mappa sempre sincronizzata con codice)
```

### Quando aggiornare la mappa (OBBLIGATORIO):

La mappa DEVE essere aggiornata SEMPRE quando fai modifiche che cambiano:

**Struttura e Organizzazione**:
- ✅ Crei/elimini file o directory
- ✅ Riorganizzi struttura progetto
- ✅ Modifichi responsabilità di file/moduli

**Architettura**:
- ✅ Modifichi layer architetturali
- ✅ Cambi pattern utilizzati
- ✅ Modifichi flussi di dati
- ✅ Aggiungi/modifichi Context, Services, Repositories

**Dipendenze**:
- ✅ Aggiungi dipendenze npm (production o dev)
- ✅ Rimuovi dipendenze npm
- ✅ Aggiorni versioni dipendenze critiche

**Database e Storage**:
- ✅ Modifichi schema IndexedDB
- ✅ Aggiungi/rimuovi object stores
- ✅ Modifichi chiavi localStorage

**Servizi e Integrazioni**:
- ✅ Aggiungi servizi esterni
- ✅ Modifichi configurazione servizi
- ✅ Implementi nuovi protocolli (es. XEP XMPP)

**Build e Configurazione**:
- ✅ Modifichi vite.config.ts
- ✅ Aggiungi script npm
- ✅ Modifichi configurazione TypeScript/ESLint

**Feature e Stato**:
- ✅ Implementi nuove feature significative
- ✅ Risolvi known issues
- ✅ Cambi stato di feature (da "roadmap" a "implementata")

**Regola d'oro**: Se non sei sicuro se aggiornare la mappa → AGGIORNALA. Meglio una mappa dettagliata e aggiornata che una obsoleta.

### Integrazione con altre regole:

- **Con Metodo Analitico**: La mappa è la base per l'analisi approfondita
- **Con Analisi Architetturale**: La mappa documenta l'architettura corrente da verificare
- **Con Revisione completa**: La mappa aiuta a identificare tutti i file da revisionare
- **Con Principio di Certezza**: La mappa riduce l'ambiguità e aumenta la certezza

### Vantaggi:

1. **Riduce ricostruzioni errate**: Documento di riferimento completo evita assunzioni sbagliate
2. **Stabilizza la memoria**: Punto di verità riletto all'inizio di ogni sessione
3. **Accelera l'analisi**: Non serve ricostruire la struttura ogni volta
4. **Migliora la coerenza**: Tutte le decisioni partono dalla stessa base architetturale
5. **Facilita onboarding**: Nuova sessione parte sempre da documento completo
6. **Garantisce armonia**: Il codice VINCOLATO alla mappa garantisce implementazioni armoniche con lo stato attuale
7. **Previene regressioni**: Impossibile fare modifiche non coerenti senza aggiornare la mappa
8. **Documentazione sempre aggiornata**: La mappa è SEMPRE fedele allo stato del software

### La mappa come contratto:

**IMPORTANTE**: La mappa è un CONTRATTO tra sessioni di lavoro.

- **Contratto per il codice**: Il codice deve rispettare l'architettura documentata
- **Contratto per le modifiche**: Ogni modifica deve mantenere o evolvere coerentemente l'architettura
- **Contratto per la documentazione**: La mappa deve SEMPRE riflettere lo stato reale del codice

Se la mappa e il codice non sono sincronizzati, il contratto è rotto e il lavoro NON è completo.

---

## Documentazione - Scrivere SOLO per me stesso, MAI per l'utente

**FONDAMENTALE: NON scrivere MAI documentazione per l'utente. La documentazione va scritta SOLO per me stesso.**

### Regole fondamentali:
- ❌ **NON creare MAI file README per l'utente**
- ❌ **NON creare MAI file di documentazione (*.md) per l'utente**
- ❌ **NON aggiungere MAI commenti nel codice per "spiegare" all'utente**
- ❌ **NON scrivere MAI guide, manuali o istruzioni per l'utente**
- ✅ **Scrivere documentazione SOLO per me stesso quando serve a tracciare:**
  - Analisi del problema
  - Decisioni architetturali prese
  - Pattern e convenzioni del codebase
  - Note per continuare il lavoro in futuro
- ✅ **La documentazione per me stesso è utile per mantenere continuità nel lavoro**
- ✅ **La documentazione per me stesso aiuta a seguire il Metodo Analitico**

### Quando posso scrivere documentazione:
- Solo se ESPLICITAMENTE richiesto dall'utente
- Solo per me stesso, per tracciare analisi e decisioni
- Mai in modo proattivo "per aiutare l'utente"

### Cosa fare invece:
- Implementare codice chiaro e auto-esplicativo
- Usare nomi di variabili e funzioni descrittivi
- Strutturare il codice in modo leggibile
- Seguire i pattern già esistenti nel codebase

---

## Metodo Analitico - Approfondire e comprendere il problema

**FONDAMENTALE: Usare sempre il metodo più analitico possibile per capire DAVVERO il problema prima di agire.**

Questa è la regola più importante: ogni azione deve essere preceduta da un'analisi approfondita. Il metodo analitico si applica a tutte le altre regole e deve essere seguito SEMPRE.

### Regole fondamentali:
- ✅ **Analizzare il problema in profondità, non fermarsi alla superficie**
- ✅ **Tracciare il flusso completo dei dati e della logica**
- ✅ **Identificare la causa radice, non solo i sintomi**
- ✅ **Considerare tutti i casi edge e scenari possibili**
- ✅ **Verificare le ipotesi con analisi del codice, non con supposizioni**
- ✅ **Mappare tutte le dipendenze e interazioni**
- ✅ **Capire il "perché" dietro ogni comportamento, non solo il "cosa"**
- ❌ **NON saltare alle conclusioni senza analisi approfondita**
- ❌ **NON fare modifiche basate su ipotesi non verificate**

### Processo analitico da seguire:
1. **Definire chiaramente il problema**: Cosa non funziona? Qual è il comportamento atteso vs quello osservato?
2. **Raccogliere informazioni**: Leggere tutto il codice rilevante, tracciare i flussi, identificare i punti di interazione
3. **Formulare ipotesi**: Basate sui dati raccolti, non su supposizioni
4. **Verificare le ipotesi**: Analizzare il codice per confermare o smentire ogni ipotesi
5. **Identificare la causa radice**: Andare oltre i sintomi per trovare la vera causa
6. **Progettare la soluzione**: Solo dopo aver compreso completamente il problema
7. **Verificare la soluzione**: Assicurarsi che risolva la causa radice, non solo i sintomi

### Tecniche analitiche da usare:
- Tracciamento completo del flusso di esecuzione
- Analisi delle dipendenze (chi dipende da cosa)
- Analisi dei dati (da dove vengono, dove vanno, come cambiano)
- Analisi degli stati (quali stati esistono, quando cambiano, perché)
- Analisi degli effetti collaterali (cosa viene influenzato dalle modifiche)
- Confronto con pattern simili nel codebase
- Verifica della coerenza architetturale

### Integrazione con altre regole:
- **Con Principio di Certezza**: L'analisi approfondita garantisce che si agisca solo con comprensione chiara
- **Con Revisione completa**: Il metodo analitico include e va oltre la revisione completa del codice
- **Con Debug e Testing**: L'analisi statica sostituisce il debug manuale
- **Con Analisi Architetturale**: Il metodo analitico deve sempre includere la verifica degli errori di design architetturale

---

## Analisi Architetturale - Cercare errori di design prima di tutto

**FONDAMENTALE: Quando si affronta un problema, cercare PRIMA gli errori di design dell'architettura software prima di cercare bug nel codice.**

Molti problemi apparentemente complessi hanno origine da errori di design architetturale. Identificare e correggere questi errori è spesso più efficace che cercare di risolvere sintomi nel codice.

### Regole fondamentali:
- ✅ **Sempre verificare prima se il problema deriva da un errore di design architetturale**
- ✅ **Analizzare la struttura complessiva del sistema prima di cercare bug specifici**
- ✅ **Verificare separazione delle responsabilità, coesione, accoppiamento**
- ✅ **Controllare se il problema è causato da violazioni di principi SOLID o pattern architetturali**
- ✅ **Valutare se la soluzione richiede un refactoring architetturale piuttosto che una patch**
- ✅ **Considerare se il problema è sintomo di un design inadeguato**
- ❌ **NON cercare solo bug nel codice senza verificare il design**
- ❌ **NON applicare patch temporanee se il problema è architetturale**

### Processo di analisi architetturale:
1. **Identificare il problema**: Cosa non funziona? Qual è il comportamento atteso?
2. **Analizzare l'architettura**: Come è strutturato il sistema? Quali sono i componenti principali?
3. **Verificare il design**: Ci sono violazioni di principi architetturali? Separazione delle responsabilità corretta?
4. **Identificare errori di design**: Il problema deriva da un design inadeguato o da un bug specifico?
5. **Valutare la soluzione**: Serve un refactoring architetturale o una correzione puntuale?
6. **Progettare la correzione**: Se è un problema architetturale, progettare la soluzione corretta

### Cosa verificare nell'analisi architetturale:
- Separazione delle responsabilità (Single Responsibility Principle)
- Coesione dei moduli e componenti
- Accoppiamento tra componenti
- Violazioni di principi SOLID
- Pattern architetturali utilizzati correttamente
- Flussi di dati e dipendenze
- Gestione degli stati e side effects
- Scalabilità e manutenibilità del design

### Integrazione con Metodo Analitico:
L'analisi architetturale è parte integrante del Metodo Analitico: quando si analizza un problema, la prima domanda deve essere "Questo problema deriva da un errore di design architetturale?"

---

## Principio di Certezza - Agire solo con comprensione chiara

**FONDAMENTALE: Agire SOLO quando ho buona certezza che l'utente abbia buona consapevolezza di quello che farò.**

### Regole fondamentali:
- ✅ **Verificare sempre che l'utente abbia compreso le implicazioni delle modifiche**
- ✅ **Spiegare chiaramente COSA farò PRIMA di procedere**
- ✅ **Chiedere conferma quando le modifiche potrebbero avere effetti non ovvi**
- ✅ **Essere esplicito su file, funzioni e logiche che verranno modificati**
- ❌ **NON procedere se c'è ambiguità sulla richiesta dell'utente**
- ❌ **NON assumere che l'utente capisca tutti i dettagli tecnici**
- ❌ **NON fare modifiche significative senza spiegare prima il piano**

### Quando fermarsi e chiedere:
1. La richiesta è vaga o ambigua
2. Ci sono multiple interpretazioni possibili
3. Le modifiche potrebbero avere effetti collaterali non ovvi
4. Il contesto fornito dall'utente è insufficiente
5. C'è incertezza su quale approccio sia preferito dall'utente

### Cosa comunicare prima di agire:
1. Quali file verranno modificati
2. Quale logica/funzionalità verrà cambiata
3. Eventuali effetti collaterali prevedibili
4. Perché questa è la soluzione scelta
5. Eventuali alternative considerate

## Revisione completa del codice - PRIMA di modificare

**IMPORTANTE: Revisionare COMPLETAMENTE il codice prima di fare qualsiasi modifica.**

Questa sezione implementa concretamente il Metodo Analitico per la revisione del codice.

### Regole fondamentali:
- ✅ **Leggere l'INTERO file che si sta per modificare, non solo le parti rilevanti**
- ✅ **Verificare TUTTE le dipendenze e i punti di utilizzo della funzione/classe/componente**
- ✅ **Capire il flusso completo e gli effetti collaterali delle modifiche**
- ✅ **Cercare pattern simili nel codebase per mantenere coerenza**
- ✅ **Verificare che le modifiche siano coerenti con il resto del codice**
- ✅ **Usare grep/search per trovare tutti i riferimenti prima di modificare**
- ✅ **Non fare modifiche senza avere certezza del contesto completo**

### Processo da seguire (applicazione del Metodo Analitico):
1. **Definire**: Quale codice devo modificare e perché?
2. **Raccogliere**: Leggere completamente il file target e tutti i file correlati
3. **Mappare**: Cercare tutti i riferimenti/usages della funzione/classe/componente
4. **Analizzare**: Capire il flusso completo (chi chiama cosa, quando, perché)
5. **Verificare**: Controllare effetti collaterali e dipendenze
6. **Progettare**: Solo DOPO aver compreso tutto, progettare le modifiche
7. **Implementare**: Fare le modifiche con piena consapevolezza del contesto

---

## Debug e Testing - NON chiedere all'utente

**IMPORTANTE: L'utente è normalmente da cellulare e non può fare debug dal browser.**

Questa sezione applica il Metodo Analitico al debugging: usare analisi statica invece di debug interattivo.

### Regole fondamentali:
- ❌ **NON chiedere mai all'utente di aprire la console del browser**
- ❌ **NON chiedere mai all'utente di controllare i log**
- ❌ **NON aggiungere console.log per debug e chiedere all'utente di testarli**
- ✅ **Analizzare il codice completamente per capire il problema** (Metodo Analitico)
- ✅ **Usare l'analisi statica del codice per trovare bug**
- ✅ **Verificare tutti i flussi logici senza bisogno di testing manuale**

### Processo di debug analitico (applicazione del Metodo Analitico):
1. **Definire il problema**: Cosa non funziona? Qual è il comportamento osservato?
2. **Raccogliere informazioni**: Leggere e analizzare tutto il codice coinvolto
3. **Tracciare il flusso**: Seguire il flusso dei dati dall'inizio alla fine
4. **Identificare i punti critici**: Trovare tutti i punti dove potrebbero esserci problemi
5. **Formulare ipotesi**: Basate sull'analisi, non su supposizioni
6. **Verificare le ipotesi**: Analizzare il codice per confermare o smentire
7. **Risolvere**: Fare modifiche basate sull'analisi statica, non su tentativi
8. **Verificare**: Usare build e lint per validare, non testing manuale

---

## Build - SEMPRE dopo modifiche

**IMPORTANTE: Fare SEMPRE il build dopo aver fatto modifiche al codice.**

Il build è parte integrante del Metodo Analitico: serve a verificare che le modifiche siano corrette prima di considerare il lavoro completato.

### Regola fondamentale:
- ✅ **SEMPRE eseguire `npm run build` nella directory `web-client` dopo ogni modifica**
- ✅ Verificare che il build completi senza errori prima di considerare il lavoro finito
- ✅ Il build è la verifica finale che le modifiche siano sintatticamente e logicamente corrette

### Quando eseguire il build:
- Dopo ogni modifica al codice
- Prima di considerare completato un task
- Come parte del processo di verifica del Metodo Analitico

---

## Riepilogo: Workflow completo

Quando si affronta un problema o una richiesta, seguire questo workflow che integra tutte le regole:

### 0. Mappa del Progetto (PRIMO STEP - OBBLIGATORIO)
**All'inizio di ogni sessione:**
- Leggere completamente `/workspace/PROJECT_MAP.md`
- Comprendere architettura corrente
- Identificare layer, responsabilità, dipendenze
- Usare la mappa come punto di verità per tutte le decisioni

### 1. Metodo Analitico (FONDAMENTALE)
- Definire chiaramente il problema
- Raccogliere tutte le informazioni necessarie (usando la mappa come base)
- Tracciare flussi, dipendenze, stati
- Identificare la causa radice
- Formulare e verificare ipotesi

### 2. Analisi Architetturale (FONDAMENTALE)
- Verificare PRIMA se il problema deriva da errori di design architetturale
- Analizzare la struttura complessiva del sistema (riferendosi alla mappa)
- Valutare se serve un refactoring architetturale o una correzione puntuale
- **Se serve refactoring architetturale, pianificare aggiornamento mappa**

### 3. Principio di Certezza
- Assicurarsi di aver compreso completamente il problema
- Spiegare all'utente cosa si farà e perché
- Chiedere conferma se necessario
- Verificare che la soluzione sia coerente con l'architettura nella mappa

### 4. Revisione completa del codice
- Leggere completamente tutti i file coinvolti
- Mappare tutte le dipendenze e usages
- Capire il flusso completo
- Verificare coerenza con architettura documentata nella mappa

### 5. Progettare la soluzione
- Solo dopo aver compreso tutto
- **Verificare che la soluzione sia coerente con la mappa (VINCOLO)**
- Considerare effetti collaterali
- Se serve deviare dall'architettura, riprogettare architettura e aggiornare mappa

### 6. Implementare
- Fare le modifiche con piena consapevolezza
- Seguire i pattern del codebase
- Mantenere coerenza con architettura documentata

### 7. Aggiornare la mappa (OBBLIGATORIO se necessario)
- **Se le modifiche hanno cambiato architettura/struttura, aggiornare `/workspace/PROJECT_MAP.md`**
- Aggiornare data ultima revisione
- Documentare cambiamenti significativi
- Verificare che la mappa sia fedele al codice

### 8. Verificare
- Eseguire il build
- Verificare lint
- Assicurarsi che la soluzione risolva la causa radice
- **Verificare che la mappa sia sincronizzata con il codice**

**Ricorda: La Mappa del Progetto è il CONTRATTO. Il Metodo Analitico è la base di tutto. Ogni altra regola si applica attraverso il metodo analitico.**
